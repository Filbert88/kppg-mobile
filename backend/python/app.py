import os
import json
import uuid
import logging
from flask import Flask, request, jsonify, send_file
# Import the fragmentation functions from your module
from frag import fragmentation_to_outline
from ocr import OCR
from kuzram import kuz_ram_model
from io import BytesIO
import uuid
import cv2
import numpy as np
import time
# Import the marker extraction functions
from object_detector import extract_marker_properties
import base64

app = Flask(__name__)

@app.route('/ocr', methods=['POST'])
def ocr_endpoint():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400

    unique_id = str(uuid.uuid4())
    temp_filename = f"temp_image_{unique_id}.jpg"
    file.save(temp_filename)

    temp_folder = "temp_ocr"
    output_folder = "output_ocr"

    try:
        OCR(temp_filename, temp_folder, output_folder)
    except Exception as e:
        os.remove(temp_filename)
        return jsonify({"error": "Error processing OCR"}), 500

    base_name = os.path.splitext(os.path.basename(temp_filename))[0]
    result_json_path = os.path.join(output_folder, f'res_{base_name}.json')

    if not os.path.exists(result_json_path):
        os.remove(temp_filename)
        return jsonify({'error': 'No OCR result found'}), 500

    with open(result_json_path, 'r') as f:
        ocr_data = json.load(f)

    response = {
        'ocr_result': ocr_data
    }
    os.remove(temp_filename)
    os.remove(result_json_path)

    return jsonify(response)

def wait_until_file_ready(path: str, timeout: float = 5.0) -> bool:
    """Retry opening the file directly until it's readable (ignore existence only)."""
    import time
    start = time.time()
    while time.time() - start < timeout:
        try:
            with open(path, "rb") as f:
                f.read(1)
            return True
        except (PermissionError, OSError):
            time.sleep(0.05)  # wait 50ms and try again
    return False

@app.route('/fragmentation-red-outline', methods=['POST'])
def fragmentation_red_outline():
    """
    This endpoint expects an image file uploaded as "file".
    It will process the image to create a segmentation result,
    then use the generated cutouts to extract marker properties.
    
    The JSON response will include:
      - output_image: the segmentation result image encoded as a base64 string.
      - marker_properties: a dict containing the marker filename,
                           the longest side in pixels, and the conversion factor.
    """
    file = request.files.get("file")
    if not file or file.filename == "":
        return jsonify({"error": "No file uploaded"}), 400

    try:
        # Generate a unique ID
        uid = str(uuid.uuid4())
        # Read the image from the request
        file_bytes = np.frombuffer(file.read(), np.uint8)
        image = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)
        if image is None:
            return jsonify({"error": "Invalid image file"}), 400

        # Save the input image temporarily
        input_filename = f"in_memory_input_{uid}.jpg"
        cv2.imwrite(input_filename, image)

        # Create a unique output folder
        output_folder = f"output_frag/output_frag_red_outline_{uid}"

        # Call fragmentation_to_outline, which processes the image, saves segmentation result
        # and cutouts; it returns the processed segmentation image.
        output_image = fragmentation_to_outline(input_filename, output_folder)

        # Clean up the temporary input file
        if os.path.exists(input_filename):
            os.remove(input_filename)

        # Determine the image name (based on the input file)
        image_name = os.path.splitext(os.path.basename(input_filename))[0]
        # Calculate the cutouts folder path generated by the segmentation process
        cutouts_folder = os.path.join(output_folder, f"cutouts_{image_name}")
        print(cutouts_folder)
        
        # Call extract_marker_properties on the cutouts folder to get the marker info
        marker_file, longest_side_px, conversion_factor = extract_marker_properties(cutouts_folder)
        marker_data = {
            "marker_file": marker_file,
            "longest_side_px": longest_side_px,
            "conversion_factor": conversion_factor
        }

        # Save the marker extraction info as JSON in the cutouts folder
        marker_properties_path = os.path.join(cutouts_folder, "marker_properties.json")
        with open(marker_properties_path, "w") as f:
            json.dump(marker_data, f)

        # Encode the output segmentation image as JPEG and then base64
        ret, buffer = cv2.imencode('.jpg', output_image)
        if not ret:
            return jsonify({"error": "Failed to encode output image"}), 500
        encoded_image = base64.b64encode(buffer).decode('utf-8')

        response = {
            "output_image": encoded_image,
            "marker_properties": marker_data
        }
        return jsonify(response)

    except Exception as e:
        return jsonify({"error": f"Fragmentation failed: {str(e)}"}), 500

@app.route('/kuzram', methods=['POST'])
def kuzram_endpoint():
    data = request.get_json()
    if not data:
        return jsonify({"error": "No JSON payload provided"}), 400
    try:
        A = float(data["A"])
        K = float(data["K"])
        Q = float(data["Q"])
        E = float(data["E"])
        n = float(data["n"])
    except (KeyError, ValueError) as e:
        return jsonify({"error": "Invalid or missing parameters"}), 400

    result = kuz_ram_model(A, K, Q, E, n)
    return jsonify(result)

if __name__ == '__main__':
    app.run(debug=True, port=5000)
